# Linux C learning

## book

[linux c编程一站式学习](https://akaedu.github.io/book/)

## ch1

<!-- 

以概念为中心的阅读思考习惯

注意区分编译时和运行时（Run-time）这两个概念

一个好的习惯是打开gcc的-Wall选项，也就是让gcc提示所有的警告信息，不管是严重的还是不严重的，
然后把这些问题从代码中全部消灭 

-->

## ch2

<!-- 

好的代码风格要求缩进整齐，每个语句一行，适当留空行

转义序列是编译时处理的，而转换说明是在运行时调用printf函数处理的

变量是计算机存储器中的一块命名的空间

一般来说应避免使用以下划线开头的标识符

理解一个概念不是把定义背下来就行了，一定要理解它的外延和内涵，也就是什么情况属于这个概念，
什么情况不属于这个概念，什么情况虽然属于这个概念但一般推荐的做法（Best Practice）
是要尽量避免这种情况，这才算是真正理解了

初始化是一种特殊的声明，而不是一种赋值语句

个由运算符和操作数所组成的算式称为表达式（Expression）, 任何表达式都有值和类型两个基本属性

表达式所表示的存储位置称为左值（lvalue）（允许放在等号左边），
而以前我们所说的表达式的值也称为右值（rvalue）（只能放在等号右边）。
上面的话换一种说法就是：有的表达式既可以做左值也可以做右值，而有的表达式只能做右值

在C语言中整数除法取的既不是Floor也不是Ceiling，无论操作数是正是负总是把小数部分截掉，
在数轴上向零的方向取整（Truncate toward Zero），或者说当操作数为正的时候相当于Floor，
当操作符为负的时候相当于Ceiling

以后我们把char型和int型统称为整数类型（Integer Type）或简称整型

-->

## ch3

<!-- 

其实操作系统在调用main函数时是传参数的，main函数最标准的形式应该是
int main(int argc, char *argv[]) 

形参相当于函数中定义的变量，调用函数传递参数的过程相当于定义形参变量并且用实参的值来初始化

如果全局变量在定义时不初始化则初始值是0，如果局部变量在定义时不初始化则初始值是不确定的。
所以，局部变量在使用之前一定要先赋值

不要把必要条件（Necessary Condition）当充分条件（Sufficient Condition）

 -->

## ch4

<!-- 

C语言规定，else总是和它上面最近的一个if配对

顺便提一下，浮点型的精度有限，不适合用==运算符做精确比较

 -->

## ch5

<!-- 

函数返回一个值相当于定义一个和返回值类型相同的临时变量并用return后面的表达式来初始化

函数的返回值不是左值，或者说函数调用表达式不能做左值

C语言的传参规则是Call by Value，按值传递，现在我们知道返回值也是按值传递的

如果你相信你正在写的递归函数是正确的，并调用它，然后在此基础上写完这个递归函数，
那么它就会是正确的，从而值得你相信它正确

写递归函数时一定要记得写Base Case

递归和循环是等价的

 -->

## ch6

<!-- 

给变量多次赋值时要格外小心，在代码中多次读写同一变量应该以一种一致的方式进行

滥用goto语句会使程序的控制流程非常复杂，可读性很差



 -->

## ch7

<!-- 

编译器可以从语法上区分哪个x是变量x，哪个x是变量z的成员x，ch19.3 第 3 节 “变量的存储布局”
会讲到这两个标识符x属于不同的**命名空间**

z1必须是局部变量才能用另一个变量x的值来初始化它的成员，
如果是全局变量就只能用常量表达式来初始化。这也是C99的新特性，
C89只允许在{}中使用常量表达式来初始化，无论是初始化全局变量还是局部变量

组合使得系统可以任意复杂，而抽象使得系统的复杂性是可以控制的，任何改动都只局限在某一层，
而不会波及整个系统。著名的计算机科学家Butler Lampson说过：
“All problems in computer science can be solved 
by another level of indirection.”这里的indirection其实就是abstraction的意思



 -->

```text
(gdb) bt
#0  min (a=-1, b=0) at ./7-2-2.c:107
#1  0x00005555555556a7 in gcd (a=-1, b=0) at ./7-2-2.c:117
#2  0x00005555555556da in gcd (a=-1, b=0) at ./7-2-2.c:126
#3  0x00005555555556da in gcd (a=-1, b=0) at ./7-2-2.c:126
#4  0x00005555555556da in gcd (a=-1, b=0) at ./7-2-2.c:126
#5  0x00005555555556da in gcd (a=-1, b=0) at ./7-2-2.c:126
#6  0x00005555555556da in gcd (a=-1, b=64) at ./7-2-2.c:126
#7  0x00005555555552fc in simplify_rational (rn=...) at ./7-2-2.c:49
#8  0x00005555555554d8 in mul_rational (a=..., b=...) at ./7-2-2.c:73
#9  0x0000555555555626 in main () at ./7-2-2.c:99
```

## ch8

<!-- 

既然不能相互赋值，也就不能用数组类型作为函数的参数或返回值

数组类型做右值使用时，自动转换成指向数组首元素的指针

写代码时应尽可能避免硬编码，这其实也是一个“提取公因式”的过程，和第 2 节 “数据抽象”
讲的抽象具有相同的作用，就是避免一个地方的改动波及到大的范围

尽管上面的方法可以准确地得到统计结果，但是效率很低，这100000个随机数需要从头到尾检查十遍，
每一遍检查只统计一种数字的出现次数。其实可以把histogram中的元素当作累加器来用，
这些随机数只需要从头到尾检查一遍（Single Pass）就可以得出结果

这种方法称为数据驱动的编程（Data-driven Programming），
写代码最重要的是选择正确的数据结构来组织信息，设计控制流程和算法尚在其次，
只要数据结构选择得正确，其它代码自然而然就变得容易理解和维护了，
就像这里的printf自然而然就被提取出来了



 -->

## ch11

<!-- 



 -->

## ch15

<!-- 

优先考虑效率，而可移植性尚在其次



 -->

## ch16

<!-- 

建议只对无符号数做位运算，以减少出错的可能

C标准规定代码中的某些点是Sequence Point，当执行到一个Sequence Point时，
在此之前的Side Effect必须全部作用完毕，在此之后的Side Effect必须一个都没发生。
至于两个Sequence Point之间的多个Side Effect哪个先发生哪个后发生则没有规定，
编译器可以任意选择各Side Effect的作用顺序

在两个Sequence Point之间，同一个变量的值只允许被改变一次

原则二：如果在两个Sequence Point之间既要读一个变量的值又要改它的值，
只有在读写顺序确定的情况下才可以这么写。



 -->

## ch12

<!-- 

算法+数据结构=程序

有什么样的数据结构就决定了可以用什么样的算法

有什么样的算法就决定了可以用什么样的数据结构



 -->